<!DOCTYPE html>
<html>
<head>
    <title>Pi Sequence with Sine Threshold & 3D Audio Waves</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .main-content {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
        }

        .main-title {
            font-size: 4rem;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
            color: #fff;
        }

        .repo-links {
            text-align: center;
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .repo-link {
            color: #fff;
            text-decoration: none;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 10px 20px;
            border: 2px solid #fff;
            border-radius: 8px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
        }

        .repo-link:hover {
            background: #fff;
            color: #000;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 255, 255, 0.4);
        }
        
        .container {
            flex: 1;
            background: #111;
            margin: 20px;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            overflow-y: auto;
        }
        
        h1 {
            text-align: center;
            color: #fff;
            margin-bottom: 40px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        h2 {
            text-align: center;
            color: #ccc;
            margin: 40px 0 20px 0;
            font-size: 1.8em;
        }
        
        .chart-container {
            position: relative;
            width: 100%;
            height: 400px;
            margin: 20px 0;
            background: #222;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
        }
        
        .wave-container {
            position: relative;
            width: 100%;
            height: 500px;
            margin: 20px 0;
            background: #000;
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid #ff0000; /* Red border to make it visible */
            overflow: hidden;
        }
        
        #waveContainer {
            width: 100%;
            height: 100%;
            background: #111;
            border: 1px solid #00ff00; /* Green border to make it visible */
            position: relative;
        }
        
        .left-controls {
            position: fixed;
            left: 0;
            top: 0;
            width: 300px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-right: 2px solid #333;
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
            box-shadow: 2px 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .right-controls {
            position: fixed;
            right: 0;
            top: 0;
            width: 300px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-left: 2px solid #333;
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
            box-shadow: -2px 0 20px rgba(0, 0, 0, 0.5);
        }

        .show-controls-btn {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
        }

        .show-controls-btn button {
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border: 2px solid #333;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .show-controls-btn button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #666;
        }
        
        .controls-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
        }
        
        .control-group h4 {
            color: #fff;
            margin: 0 0 10px 0;
            font-size: 0.9em;
            text-align: center;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }
        
        .wave-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .wave-controls h3 {
            color: #fff;
            margin: 0 0 15px 0;
            font-size: 1.2em;
        }
        
        .control-group label {
            display: block;
            color: #fff;
            margin: 8px 0 4px 0;
            font-size: 0.9em;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin: 4px 0;
        }
        
        .control-group select {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            background: #333;
            color: #fff;
            border: 1px solid #666;
            border-radius: 5px;
        }
        
        .control-group button {
            padding: 8px 12px;
            margin: 3px;
            background: #444;
            color: #fff;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.3s;
            width: 100%;
        }
        
        .control-group button:hover {
            background: #555;
            transform: translateY(-1px);
        }
        
        .control-group button.active {
            background: #667eea;
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .control-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .wave-controls {
            display: none; /* Hide old controls, using global ones now */
        }
        
        .charts-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: none; /* Start hidden */
            overflow-y: auto;
            padding: 20px;
        }
        
        .charts-overlay.active {
            display: block;
        }
        
        .charts-content {
            max-width: 1200px;
            margin: 0 auto;
            background: #111;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
        }
        
        .charts-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .charts-title {
            color: #fff;
            font-size: 1.5em;
            margin: 0;
        }
        
        .close-charts {
            background: #ff4444;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.3s;
        }
        
        .close-charts:hover {
            background: #ff6666;
        }
        
        .overlay-chart-container {
            position: relative;
            width: 100%;
            height: 400px;
            margin: 20px 0;
            background: #222;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
        }
        
        canvas {
            max-width: 100% !important;
            height: auto !important;
        }
        
        @media (max-width: 768px) {
            .left-controls, .right-controls {
                width: 250px;
                font-size: 0.8em;
            }
            
            .main-content {
                margin-left: 250px;
                margin-right: 250px;
            }
            
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            h2 {
                font-size: 1.2em;
            }
            
            .chart-container {
                height: 300px;
                padding: 10px;
            }
            
            .wave-container {
                height: 400px;
                padding: 5px;
            }
        }
        
        @media (max-width: 1024px) {
            .left-controls, .right-controls {
                width: 250px;
            }
            
            .main-content {
                margin-left: 250px;
                margin-right: 250px;
            }
        }
    </style>
</head>
<body>
    <!-- Left Side Controls -->
    <div class="left-controls">
        <div class="controls-grid">
            <div class="control-group">
                <h4>ðŸŽµ Tempo Control</h4>
                <label>Tempo (75-303 BPM): <input type="range" id="tempoSlider" min="75" max="303" value="130" step="1"></label>
                <span id="tempoValue" style="color: #fff; font-weight: bold;">130 BPM</span>
            </div>
            
            <div class="control-group">
                <h4>ðŸŽ¼ Note Type</h4>
                <label>Duration: 
                    <select id="noteType">
                        <option value="1/16th">1/16th Note</option>
                        <option value="1/8th">1/8th Note</option>
                        <option value="1/4">1/4 Note</option>
                        <option value="1/2">1/2 Note</option>
                        <option value="1">Whole Note</option>
                    </select>
                </label>
            </div>
            
            <div class="control-group">
                <h4>ðŸŒŠ Wave Ratio</h4>
                <label>Ratio (1.0-3.6): <input type="range" id="ratioSlider" min="1.0" max="3.6" value="2.5" step="0.1"></label>
                <span id="ratioValue" style="color: #fff; font-weight: bold;">2.5</span>
            </div>
            
            <div class="control-group">
                <h4>ðŸ“Š Chart Controls</h4>
                <button id="showCharts">Show Charts</button>
                <button id="resetCharts">Reset Charts</button>
                <button id="animateCharts">Animate Data</button>
            </div>
        </div>
    </div>

    <!-- Right Side Controls -->
    <div class="right-controls">
        <div class="controls-grid">
            <div class="control-group">
                <h4>ðŸŽ­ Wave Types</h4>
                <button id="toggleSine">Sine</button>
                <button id="toggleSquare">Square</button>
                <button id="toggleTriangle">Triangle</button>
                <button id="toggleSawtooth">Sawtooth</button>
            </div>
            
            <div class="control-group">
                <h4>ðŸŽ® 3D Controls</h4>
                <button id="reset3D">Reset 3D View</button>
                <button id="toggleIndicator">Toggle Indicator</button>
                <button id="toggleWireframe">Wireframe</button>
            </div>
            
            <div class="control-group">
                <h4>ðŸŽ¨ Display</h4>
                <button id="toggleFullscreen">Fullscreen</button>
                <button id="toggleControls">Hide Controls</button>
            </div>
            
            <div class="control-group">
                <h4>ðŸ”Š Audio</h4>
                <button id="toggleMute">Unmute Video</button>
            </div>
        </div>
    </div>

    <!-- Show Controls Button (hidden by default) -->
    <div class="show-controls-btn" id="showControlsBtn" style="display: none;">
        <button>Show Controls</button>
    </div>

    <!-- Charts Overlay -->
    <div class="charts-overlay" id="chartsOverlay">
        <div class="charts-content">
            <div class="charts-header">
                <h2 class="charts-title">ðŸ“Š Pi Sequence Charts</h2>
                <button class="close-charts" id="closeCharts">âœ• Close Charts</button>
            </div>
            
            <h3>Natural Calculation: Fractional Digits with Sine Threshold (Scale 1-9)</h3>
            <div class="overlay-chart-container">
                <canvas id="naturalChart"></canvas>
            </div>
            
            <h3>Music Notes Version: Notes with Sine Threshold (Scale 1-8)</h3>
            <div class="overlay-chart-container">
                <canvas id="musicChart"></canvas>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div class="container">
            <h1 class="main-title">SHINE DARK</h1>
            <h2>Pi Sequence with Sine Threshold Visualization</h2>
            
            <div class="repo-links">
                <a href="https://github.com/shinedark/SD-ALGO" target="_blank" class="repo-link">SD-ALGO Repository</a>
                <a href="https://github.com/shinedark/anti-gravity-sep-6-2025-" target="_blank" class="repo-link">Anti-Gravity Repository</a>
            </div>
            
            <h3>3D Audio Wave Visualization</h3>
            <div class="wave-container">
                <div id="waveContainer"></div>
                <!-- Video element for Three.js texture -->
                <video id="videoElement" 
                       preload="auto" 
                       muted 
                       autoplay 
                       loop 
                       playsinline 
                       style="display: none;">
                    <source src="remastered.mp4" type="video/mp4">
                    <source src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>
        </div>
    </div>

    <script>
        // Global state management
        let globalState = {
            tempo: 130,
            noteType: '1/8th',
            ratio: 2.5,
            chartsVisible: true,
            indicatorEnabled: true,
            wireframeMode: false,
            waveStates: {
                sine: true,
                square: true,
                triangle: true,
                sawtooth: true
            }
        };

        // Natural Calculation Data (from previous response)
        const steps = Array.from({ length: 16 }, (_, i) => i + 1);
        const naturalDigits = [0, 3, 0, 3, 0, 3, 8, 3, 0, 3, 0, 3, 0, 3, 0, 3];
        const naturalThreshold = steps.map(i => 4.5 + 4.5 * Math.sin(2 * Math.PI * 3 * (i - 1) / 15));

        // Music Notes Data (scale 1-8, mapped notes)
        const musicDigits = [1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4];
        const musicThreshold = steps.map(i => 4 + 4 * Math.sin(2 * Math.PI * 3 * (i - 1) / 15));

        // Chart instances
        let naturalChartInstance = null;
        let musicChartInstance = null;
        let waveDemo = null;

        // Chart 1: Natural Calculation
        console.log('Initializing natural chart...');
        const naturalCtx = document.getElementById('naturalChart').getContext('2d');
        console.log('Natural chart context:', naturalCtx);
        naturalChartInstance = new Chart(naturalCtx, {
            type: 'line',
            data: {
                labels: steps,
                datasets: [
                    {
                        label: 'Fractional Digit',
                        data: naturalDigits,
                        borderColor: '#FF6B6B',
                        backgroundColor: 'rgba(255, 107, 107, 0.2)',
                        fill: true,
                        pointRadius: 8,
                        pointBackgroundColor: '#FF6B6B',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 3,
                        pointHoverRadius: 10,
                        tension: 0.4,
                        borderWidth: 4
                    },
                    {
                        label: 'Sine Threshold (Scale 1-9)',
                        data: naturalThreshold,
                        borderColor: '#4ECDC4',
                        backgroundColor: 'rgba(78, 205, 196, 0.2)',
                        fill: true,
                        pointRadius: 0,
                        borderDash: [8, 8],
                        tension: 0.4,
                        borderWidth: 3
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 9,
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)',
                            lineWidth: 1
                        },
                        title: { 
                            display: true, 
                            text: 'Fractional Digit / Threshold',
                            font: { size: 16, weight: 'bold' },
                            color: '#fff'
                        },
                        ticks: {
                            font: { size: 14 },
                            color: '#ccc'
                        }
                    },
                    x: { 
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)',
                            lineWidth: 1
                        },
                        title: { 
                            display: true, 
                            text: 'Step',
                            font: { size: 16, weight: 'bold' },
                            color: '#fff'
                        },
                        ticks: {
                            font: { size: 14 },
                            color: '#ccc'
                        }
                    }
                },
                plugins: { 
                    legend: {
                        labels: {
                            font: { size: 14, weight: 'bold' },
                            padding: 20,
                            usePointStyle: true,
                            pointStyle: 'circle',
                            color: '#fff'
                        }
                    },
                    title: { 
                        display: true, 
                        text: 'Natural Calculation: Ï€-based Sequence with Sine Threshold',
                        font: { size: 18, weight: 'bold' },
                        color: '#fff',
                        padding: 20
                    }
                }
            }
        });

        // Chart 2: Music Notes Version
        console.log('Initializing music chart...');
        const musicCtx = document.getElementById('musicChart').getContext('2d');
        console.log('Music chart context:', musicCtx);
        musicChartInstance = new Chart(musicCtx, {
            type: 'line',
            data: {
                labels: steps,
                datasets: [
                    {
                        label: 'Mapped Note (1-8)',
                        data: musicDigits,
                        borderColor: '#9B59B6',
                        backgroundColor: 'rgba(155, 89, 182, 0.2)',
                        fill: true,
                        pointRadius: 8,
                        pointBackgroundColor: '#9B59B6',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 3,
                        pointHoverRadius: 10,
                        tension: 0.4,
                        borderWidth: 4
                    },
                    {
                        label: 'Sine Threshold (Scale 1-8)',
                        data: musicThreshold,
                        borderColor: '#E74C3C',
                        backgroundColor: 'rgba(231, 76, 60, 0.2)',
                        fill: true,
                        pointRadius: 0,
                        borderDash: [8, 8],
                        tension: 0.4,
                        borderWidth: 3
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 8,
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)',
                            lineWidth: 1
                        },
                        title: { 
                            display: true, 
                            text: 'Note Value / Threshold',
                            font: { size: 16, weight: 'bold' },
                            color: '#fff'
                        },
                        ticks: {
                            font: { size: 14 },
                            color: '#ccc'
                        }
                    },
                    x: { 
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)',
                            lineWidth: 1
                        },
                        title: { 
                            display: true, 
                            text: 'Step',
                            font: { size: 16, weight: 'bold' },
                            color: '#fff'
                        },
                        ticks: {
                            font: { size: 14 },
                            color: '#ccc'
                        }
                    }
                },
                plugins: { 
                    legend: {
                        labels: {
                            font: { size: 14, weight: 'bold' },
                            padding: 20,
                            usePointStyle: true,
                            pointStyle: 'circle',
                            color: '#fff'
                        }
                    },
                    title: { 
                        display: true, 
                        text: 'Music Notes: Ï€-based Sequence with Sine Threshold',
                        font: { size: 18, weight: 'bold' },
                        color: '#fff',
                        padding: 20
                    }
                }
            }
        });

        // MIDI Rhythm Output for Music Notes Version
        console.log("MIDI Rhythm (Notes 1 or 4, 1/8th Note Durations):");
        const tempos = [75, 130, 303];
        tempos.forEach(tempo => {
            const noteDuration = 60 / tempo / 2; // 1/8th note in seconds (BPM to seconds)
            console.log(`At ${tempo} BPM (1/8th note = ${noteDuration.toFixed(3)}s):`);
            musicDigits.forEach((note, i) => {
                console.log(`Step ${i + 1}: Note ${note} (duration ${noteDuration.toFixed(3)}s)`);
            });
        });

        // Three.js Wave Visualization Class
        class ShineDarkWaveDemo {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                console.log('Container found:', this.container);
                console.log('Container size:', this.container.clientWidth, 'x', this.container.clientHeight);
                
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setClearColor(0x000000, 1);
                this.renderer.domElement.style.width = '100%';
                this.renderer.domElement.style.height = '100%';
                this.renderer.domElement.style.display = 'block';
                this.container.appendChild(this.renderer.domElement);
                
                console.log('Renderer created and added to container');
                
                // Add OrbitControls if available
                if (typeof THREE.OrbitControls !== 'undefined') {
                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                }
                this.camera.position.set(15, 2, 8); // Better view of 3 cycles
                console.log('Camera positioned at z=5');

                this.tempo = 130;
                this.noteType = '1/8th';
                this.ratio = 2.5; // <3.3 for sync
                this.time = 0;

                // Add waves with colors matching the chart themes
                this.waves = {};
                this.waveTypes = ['sine', 'square', 'triangle', 'sawtooth'];
                const waveColors = [0x00FF00, 0x0080FF, 0xFF8000, 0xFF0080]; // Clean colors: Green, Blue, Orange, Pink
                
                console.log('Creating waves...');
                this.waveTypes.forEach((type, index) => {
                    const geometry = new THREE.BufferGeometry();
                    const material = new THREE.LineBasicMaterial({ 
                        color: waveColors[index],
                        linewidth: 3
                    });
                    const line = new THREE.Line(geometry, material);
                    this.scene.add(line);
                    this.waves[type] = { line, visible: true };
                    this.updateWave(type);
                    console.log(`Created ${type} wave`);
                });

                // Create live indicator for wave synchronization
                console.log('Creating live indicator...');
                this.liveIndicator = this.createLiveIndicator();
                this.scene.add(this.liveIndicator);
                this.indicatorProgress = 0; // 0 to 1 across the 3 cycles
                this.noteStartTime = 0;
                this.currentNoteDuration = 0;
                console.log('Live indicator created and added to scene');

                // Use the HTML video element
                this.video = document.getElementById('videoElement');
                this.videoTexture = null;
                this.videoCube = null;
                
                // Handle video loading
                this.video.addEventListener('loadeddata', () => {
                    console.log('Video loaded successfully, creating texture...');
                    this.createVideoTexture();
                });
                
                this.video.addEventListener('canplaythrough', () => {
                    console.log('Video can play through, starting...');
                    this.video.play().catch(e => console.log('Video autoplay prevented:', e));
                });
                
                this.video.addEventListener('error', (e) => {
                    console.log('Video error:', e);
                    // Try to load the fallback video
                    this.video.src = 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4';
                    this.video.load();
                });
                
                // Ensure video is muted for autoplay
                this.video.muted = true;
                
                // Start loading the video
                this.video.load();
                
                // Force play after a short delay
                setTimeout(() => {
                    this.video.play().catch(e => console.log('Video play failed:', e));
                }, 1000);

                this.initControls();
                console.log('Starting animation loop...');
                this.animate();
            }

            createVideoTexture() {
                if (this.videoTexture) return; // Already created
                
                console.log('Creating video texture...');
                this.videoTexture = new THREE.VideoTexture(this.video);
                this.videoTexture.minFilter = THREE.LinearFilter;
                this.videoTexture.magFilter = THREE.LinearFilter;
                this.videoTexture.format = THREE.RGBAFormat;
                
                // Create 3 cubes with video texture positioned at the top
                this.videoCubes = [];
                const cubeGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                const cubeMaterial = new THREE.MeshBasicMaterial({ 
                    map: this.videoTexture,
                    side: THREE.DoubleSide
                });
                
                // Create 3 cubes in a row at the top
                for (let i = 0; i < 3; i++) {
                    const videoCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                    videoCube.position.set((i - 1) * 3, 4, 0); // Top row, spaced apart
                    this.scene.add(videoCube);
                    this.videoCubes.push(videoCube);
                }
                console.log('3 video cubes added to scene at top');
            }

            hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return { r, g, b };
            }

            createLiveIndicator() {
                // Create a group for the live indicator
                const indicatorGroup = new THREE.Group();
                
                // Main indicator line (vertical line that moves across waves)
                const lineGeometry = new THREE.BufferGeometry().setAttribute('position', 
                    new THREE.BufferAttribute(new Float32Array([
                        0, -3, 0,  // Start point
                        0, 3, 0    // End point
                    ]), 3)
                );
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xFF0000, 
                    linewidth: 4,
                    transparent: true,
                    opacity: 0.9
                });
                const indicatorLine = new THREE.Line(lineGeometry, lineMaterial);
                indicatorGroup.add(indicatorLine);
                
                // Note duration indicator (horizontal bar showing note length)
                const durationGeometry = new THREE.BufferGeometry().setAttribute('position',
                    new THREE.BufferAttribute(new Float32Array([
                        -0.5, 0, 0,  // Start
                        0.5, 0, 0    // End
                    ]), 3)
                );
                const durationMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x00FF00, 
                    linewidth: 6,
                    transparent: true,
                    opacity: 0.7
                });
                const durationLine = new THREE.Line(durationGeometry, durationMaterial);
                durationLine.position.y = 2.5; // Above the waves
                indicatorGroup.add(durationLine);
                
                // Pulse effect sphere
                const sphereGeometry = new THREE.SphereGeometry(0.1, 8, 6);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFFFF00,
                    transparent: true,
                    opacity: 0.8
                });
                const pulseSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                pulseSphere.position.y = 2.5;
                indicatorGroup.add(pulseSphere);
                
                return indicatorGroup;
            }

            getNoteDuration() {
                let noteMultiplier;
                switch (this.noteType) {
                    case '1/16th': noteMultiplier = 0.0625; break;
                    case '1/8th': noteMultiplier = 0.125; break;
                    case '1/4': noteMultiplier = 0.25; break;
                    case '1/2': noteMultiplier = 0.5; break;
                    case '1': noteMultiplier = 1.0; break;
                    default: noteMultiplier = 0.125;
                }
                return noteMultiplier * (60 / this.tempo);
            }

            updateLiveIndicator(noteDuration) {
                if (!this.liveIndicator) return;
                
                // Calculate progress across the 3 cycles (0 to 1)
                const cycleProgress = (this.time % noteDuration) / noteDuration;
                
                // Position the indicator across the 3 cycles (30 units total width)
                const xPosition = (cycleProgress * 30) - 15; // -15 to +15
                this.liveIndicator.position.x = xPosition;
                
                // Update note duration indicator width
                const durationLine = this.liveIndicator.children[1]; // Duration line
                const durationWidth = noteDuration * 2; // Scale for visibility
                const durationPositions = durationLine.geometry.attributes.position.array;
                durationPositions[0] = -durationWidth / 2; // Start
                durationPositions[3] = durationWidth / 2;  // End
                durationLine.geometry.attributes.position.needsUpdate = true;
                
                // Pulse effect on note boundaries
                const pulseSphere = this.liveIndicator.children[2]; // Pulse sphere
                const pulseIntensity = Math.sin(this.time * 10) * 0.5 + 0.5; // 0 to 1
                pulseSphere.scale.setScalar(0.5 + pulseIntensity * 0.5);
                
                // Color changes based on tempo
                const tempoIntensity = (this.tempo - 75) / (303 - 75); // 0 to 1
                const hue = tempoIntensity; // Red to blue based on tempo
                const rgb = this.hslToRgb(hue, 1, 0.5);
                
                // Update indicator line color
                const indicatorLine = this.liveIndicator.children[0];
                indicatorLine.material.color.setRGB(rgb.r, rgb.g, rgb.b);
                
                // Update duration line color (complementary)
                const durationHue = (hue + 0.5) % 1;
                const durationRgb = this.hslToRgb(durationHue, 1, 0.5);
                durationLine.material.color.setRGB(durationRgb.r, durationRgb.g, durationRgb.b);
            }

            updateWave(type) {
                if (!this.waves[type].visible) return;
                
                // Show 3 cycles of the wave
                const pointsPerCycle = 100;
                const totalPoints = pointsPerCycle * 3;
                const positions = new Float32Array(totalPoints * 3);
                
                for (let i = 0; i < totalPoints; i++) {
                    const cycleIndex = Math.floor(i / pointsPerCycle);
                    const cycleProgress = (i % pointsPerCycle) / pointsPerCycle;
                    const x = (cycleProgress * 10) - 5 + (cycleIndex * 10); // 3 cycles side by side
                    
                    let y;
                    const phase = this.time * this.ratio; // Phasing with ratio <3.3
                    const waveX = cycleProgress * 2 * Math.PI; // Full cycle per section
                    
                    switch (type) {
                        case 'sine': y = Math.sin(waveX + phase); break;
                        case 'square': y = Math.sign(Math.sin(waveX + phase)); break;
                        case 'triangle': y = (2 / Math.PI) * Math.asin(Math.sin(waveX + phase)); break;
                        case 'sawtooth': y = 2 * ((waveX + phase) % (2 * Math.PI) / (2 * Math.PI) - 0.5); break;
                    }
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y * 2;
                    positions[i * 3 + 2] = 0;
                }
                
                this.waves[type].line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                const delta = 0.01 * (this.tempo / 60); // Tempo controls speed
                this.time += delta;

                // Calculate note duration based on tempo and note type
                const noteDuration = this.getNoteDuration();
                
                // Update live indicator
                this.updateLiveIndicator(noteDuration);
                
                // Update waves
                this.waveTypes.forEach(type => this.updateWave(type));

                // Update video texture
                if (this.videoTexture) {
                    this.videoTexture.needsUpdate = true;
                }

                // Rotate video cube
                if (this.videoCube) {
                    this.videoCube.rotation.x += 0.005;
                    this.videoCube.rotation.y += 0.01;
                }

                // Update waves
                this.waveTypes.forEach(type => this.updateWave(type));

                if (this.controls) this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            initControls() {
                // Only handle window resize - other controls are handled globally
                window.addEventListener('resize', () => {
                    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                });
            }
        }

        // Control wiring and event handlers
        function initializeControls() {
            // Tempo control
            const tempoSlider = document.getElementById('tempoSlider');
            if (tempoSlider) {
                tempoSlider.addEventListener('input', (e) => {
                    globalState.tempo = parseInt(e.target.value);
                    const tempoValue = document.getElementById('tempoValue');
                    if (tempoValue) {
                        tempoValue.textContent = `${globalState.tempo} BPM`;
                    }
                    if (waveDemo) {
                        waveDemo.tempo = globalState.tempo;
                    }
                    updateChartsWithTempo();
                });
            }

            // Note type control
            const noteTypeSelect = document.getElementById('noteType');
            if (noteTypeSelect) {
                noteTypeSelect.addEventListener('change', (e) => {
                    globalState.noteType = e.target.value;
                    if (waveDemo) {
                        waveDemo.noteType = globalState.noteType;
                    }
                });
            }

            // Wave ratio control
            const ratioSlider = document.getElementById('ratioSlider');
            if (ratioSlider) {
                ratioSlider.addEventListener('input', (e) => {
                    globalState.ratio = parseFloat(e.target.value);
                    const ratioValue = document.getElementById('ratioValue');
                    if (ratioValue) {
                        ratioValue.textContent = globalState.ratio.toFixed(1);
                    }
                    if (waveDemo) {
                        waveDemo.ratio = globalState.ratio;
                    }
                });
            }

            // Chart controls
            const showChartsBtn = document.getElementById('showCharts');
            if (showChartsBtn) {
                showChartsBtn.addEventListener('click', () => {
                    const chartsOverlay = document.getElementById('chartsOverlay');
                    if (chartsOverlay) {
                        const isActive = chartsOverlay.classList.contains('active');
                        if (isActive) {
                            chartsOverlay.classList.remove('active');
                            showChartsBtn.textContent = 'Show Charts';
                            showChartsBtn.classList.remove('active');
                        } else {
                            chartsOverlay.classList.add('active');
                            showChartsBtn.textContent = 'Hide Charts';
                            showChartsBtn.classList.add('active');
                        }
                    }
                });
            }

            const closeChartsBtn = document.getElementById('closeCharts');
            if (closeChartsBtn) {
                closeChartsBtn.addEventListener('click', () => {
                    closeChartsOverlay();
                });
            }

            // Close overlay with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeChartsOverlay();
                }
            });

            // Close overlay when clicking outside
            const chartsOverlay = document.getElementById('chartsOverlay');
            if (chartsOverlay) {
                chartsOverlay.addEventListener('click', (e) => {
                    if (e.target === chartsOverlay) {
                        closeChartsOverlay();
                    }
                });
            }

            function closeChartsOverlay() {
                const chartsOverlay = document.getElementById('chartsOverlay');
                if (chartsOverlay) {
                    chartsOverlay.classList.remove('active');
                    const showChartsBtn = document.getElementById('showCharts');
                    if (showChartsBtn) {
                        showChartsBtn.textContent = 'Show Charts';
                        showChartsBtn.classList.remove('active');
                    }
                }
            }

            const resetChartsBtn = document.getElementById('resetCharts');
            if (resetChartsBtn) {
                resetChartsBtn.addEventListener('click', () => {
                    if (naturalChartInstance) naturalChartInstance.reset();
                    if (musicChartInstance) musicChartInstance.reset();
                });
            }

            const animateChartsBtn = document.getElementById('animateCharts');
            if (animateChartsBtn) {
                animateChartsBtn.addEventListener('click', () => {
                    animateCharts();
                });
            }

            // Wave type toggles
            ['sine', 'square', 'triangle', 'sawtooth'].forEach(type => {
                const button = document.getElementById(`toggle${type.charAt(0).toUpperCase() + type.slice(1)}`);
                if (button) {
                    button.addEventListener('click', () => {
                        globalState.waveStates[type] = !globalState.waveStates[type];
                        button.classList.toggle('active', globalState.waveStates[type]);
                        if (waveDemo && waveDemo.waves[type]) {
                            waveDemo.waves[type].visible = globalState.waveStates[type];
                            waveDemo.waves[type].line.visible = globalState.waveStates[type];
                        }
                    });
                }
            });

            // 3D controls
            const reset3DBtn = document.getElementById('reset3D');
            if (reset3DBtn) {
                reset3DBtn.addEventListener('click', () => {
                    if (waveDemo) {
                        waveDemo.camera.position.set(0, 0, 5);
                        if (waveDemo.controls) waveDemo.controls.reset();
                    }
                });
            }

            const toggleIndicatorBtn = document.getElementById('toggleIndicator');
            if (toggleIndicatorBtn) {
                toggleIndicatorBtn.addEventListener('click', () => {
                    globalState.indicatorEnabled = !globalState.indicatorEnabled;
                    if (waveDemo && waveDemo.liveIndicator) {
                        waveDemo.liveIndicator.visible = globalState.indicatorEnabled;
                    }
                    toggleIndicatorBtn.classList.toggle('active', globalState.indicatorEnabled);
                });
            }

            const toggleWireframeBtn = document.getElementById('toggleWireframe');
            if (toggleWireframeBtn) {
                toggleWireframeBtn.addEventListener('click', () => {
                    globalState.wireframeMode = !globalState.wireframeMode;
                    if (waveDemo) {
                        waveDemo.waveTypes.forEach(type => {
                            if (waveDemo.waves[type]) {
                                waveDemo.waves[type].line.material.wireframe = globalState.wireframeMode;
                            }
                        });
                    }
                    toggleWireframeBtn.classList.toggle('active', globalState.wireframeMode);
                });
            }

            // New display controls
            const toggleFullscreenBtn = document.getElementById('toggleFullscreen');
            if (toggleFullscreenBtn) {
                toggleFullscreenBtn.addEventListener('click', () => {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                    } else {
                        document.exitFullscreen();
                    }
                });
            }

            const toggleControlsBtn = document.getElementById('toggleControls');
            if (toggleControlsBtn) {
                toggleControlsBtn.addEventListener('click', () => {
                    const leftControls = document.querySelector('.left-controls');
                    const rightControls = document.querySelector('.right-controls');
                    const showControlsBtn = document.getElementById('showControlsBtn');
                    const isHidden = leftControls.style.display === 'none';
                    
                    leftControls.style.display = isHidden ? 'block' : 'none';
                    rightControls.style.display = isHidden ? 'block' : 'none';
                    showControlsBtn.style.display = isHidden ? 'none' : 'block';
                    toggleControlsBtn.textContent = isHidden ? 'Hide Controls' : 'Show Controls';
                });
            }

            // Show Controls Button
            const showControlsBtn = document.getElementById('showControlsBtn');
            if (showControlsBtn) {
                showControlsBtn.addEventListener('click', () => {
                    const leftControls = document.querySelector('.left-controls');
                    const rightControls = document.querySelector('.right-controls');
                    const toggleControlsBtn = document.getElementById('toggleControls');
                    
                    leftControls.style.display = 'block';
                    rightControls.style.display = 'block';
                    showControlsBtn.style.display = 'none';
                    toggleControlsBtn.textContent = 'Hide Controls';
                });
            }

            // Mute/Unmute Video Button
            const toggleMuteBtn = document.getElementById('toggleMute');
            if (toggleMuteBtn) {
                toggleMuteBtn.addEventListener('click', () => {
                    const video = document.getElementById('videoElement');
                    if (video) {
                        video.muted = !video.muted;
                        toggleMuteBtn.textContent = video.muted ? 'Unmute Video' : 'Mute Video';
                        toggleMuteBtn.classList.toggle('active', !video.muted);
                    }
                });
            }

            // Initialize button states
            const toggleIndicatorBtnInit = document.getElementById('toggleIndicator');
            if (toggleIndicatorBtnInit) toggleIndicatorBtnInit.classList.add('active');
            
            ['sine', 'square', 'triangle', 'sawtooth'].forEach(type => {
                const button = document.getElementById(`toggle${type.charAt(0).toUpperCase() + type.slice(1)}`);
                if (button) button.classList.add('active');
            });
        }

        // Update charts with tempo-based animation
        function updateChartsWithTempo() {
            if (!naturalChartInstance || !musicChartInstance) return;
            
            const tempoMultiplier = globalState.tempo / 130; // Normalize to 130 BPM
            const animationSpeed = 0.5 + (tempoMultiplier * 0.5);
            
            // Update chart animation options
            naturalChartInstance.options.animation.duration = 1000 / animationSpeed;
            musicChartInstance.options.animation.duration = 1000 / animationSpeed;
        }

        // Animate charts with dynamic data
        function animateCharts() {
            if (!naturalChartInstance || !musicChartInstance) return;
            
            // Create animated data based on tempo
            const animatedNatural = naturalDigits.map((digit, i) => {
                const phase = (Date.now() * 0.001 * globalState.tempo / 60) + (i * 0.5);
                return digit + Math.sin(phase) * 0.5;
            });
            
            const animatedMusic = musicDigits.map((digit, i) => {
                const phase = (Date.now() * 0.001 * globalState.tempo / 60) + (i * 0.3);
                return digit + Math.sin(phase) * 0.3;
            });
            
            // Update chart data
            naturalChartInstance.data.datasets[0].data = animatedNatural;
            musicChartInstance.data.datasets[0].data = animatedMusic;
            
            naturalChartInstance.update('active');
            musicChartInstance.update('active');
        }

        // Initialize everything after the page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing...');
            
            // Initialize controls first
            initializeControls();
            
            // Initialize charts immediately
            console.log('Initializing charts...');
            
            // Start a simple animation test for charts
            setTimeout(() => {
                console.log('Starting chart animation test...');
                if (naturalChartInstance && musicChartInstance) {
                    console.log('Charts found, starting animation...');
                    animateCharts();
                }
            }, 1000);
            
            // Wait for everything to be ready, then initialize the wave visualization
            setTimeout(() => {
                const waveContainer = document.getElementById('waveContainer');
                if (waveContainer) {
                    console.log('Wave container found, initializing 3D render...');
                    console.log('Container dimensions:', waveContainer.clientWidth, 'x', waveContainer.clientHeight);
                    console.log('Container position:', waveContainer.offsetLeft, waveContainer.offsetTop);
                    console.log('Container visible:', waveContainer.offsetWidth > 0 && waveContainer.offsetHeight > 0);
                    
                    // Force container to have dimensions if it doesn't
                    if (waveContainer.clientWidth === 0 || waveContainer.clientHeight === 0) {
                        console.log('Container has zero dimensions, forcing size...');
                        waveContainer.style.width = '100%';
                        waveContainer.style.height = '480px';
                        waveContainer.style.minHeight = '480px';
                    }
                    
                    waveDemo = new ShineDarkWaveDemo('waveContainer');
                    console.log('3D render initialized');
                } else {
                    console.error('Wave container not found!');
                    // Let's check what containers exist
                    const allContainers = document.querySelectorAll('div[id*="wave"], div[class*="wave"]');
                    console.log('Available wave-related containers:', allContainers);
                    
                    // Try to find the wave-container and create the inner div
                    const waveContainerDiv = document.querySelector('.wave-container');
                    if (waveContainerDiv) {
                        console.log('Found .wave-container, creating inner div...');
                        const innerDiv = document.createElement('div');
                        innerDiv.id = 'waveContainer';
                        innerDiv.style.width = '100%';
                        innerDiv.style.height = '480px';
                        innerDiv.style.background = '#111';
                        innerDiv.style.border = '1px solid #00ff00';
                        waveContainerDiv.appendChild(innerDiv);
                        
                        // Try again
                        setTimeout(() => {
                            waveDemo = new ShineDarkWaveDemo('waveContainer');
                            console.log('3D render initialized after creating container');
                        }, 100);
                    }
                }
            }, 500);
        });
    </script>
</body>
</html>
